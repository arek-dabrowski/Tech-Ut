package com.example.jdbcdemo.service;

import java.sql.Connection;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import com.example.jdbcdemo.domain.Gun;

import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class GunServiceJDBC implements GunService {
	
	private static Connection connection;
	private static Statement statement;
	
	private final String URL = "jdbc:hsqldb:hsql://localhost/workdb";
	private final String CREATE_TABLE_SQL = "CREATE TABLE Gun(id bigint GENERATED BY DEFAULT AS IDENTITY, name varchar(20) UNIQUE NOT NULL, productionDate date NOT NULL, damaged boolean NOT NULL, weight double NOT NULL)";

	private PreparedStatement addGunStmt;
	private PreparedStatement deleteAllGunsStmt;
	private PreparedStatement deleteGunStmt;
	private PreparedStatement getGunStmt;
	private PreparedStatement getAllGunsStmt;
	private PreparedStatement getAllUndamagedGunsStmt;
	private PreparedStatement updateGunStmt;
	
	public GunServiceJDBC() throws SQLException {
		
		connection = DriverManager.getConnection(URL);
		statement = connection.createStatement();
		
		ResultSet rs = connection.getMetaData().getTables(null, null, null, null);
		
		boolean tableExists = false;
		while(rs.next()) {
			if("Gun".equalsIgnoreCase(rs.getString("table_name"))) {
				tableExists = true;
				break;
			}
		}
		
		if(!tableExists) statement.executeUpdate(CREATE_TABLE_SQL);
		
		addGunStmt = connection.prepareStatement("INSERT INTO Gun(name, productionDate, damaged, weight) VALUES (?, ?, ?, ?)");
		deleteAllGunsStmt = connection.prepareStatement("DELETE FROM Gun");
		deleteGunStmt = connection.prepareStatement("DELETE FROM Gun WHERE id=?");
		getAllGunsStmt = connection.prepareStatement("SELECT id, name, productionDate, damaged, weight FROM Gun");
		getGunStmt = connection.prepareStatement("SELECT id, name, productionDate, damaged, weight FROM Gun WHERE id=?");
		getAllUndamagedGunsStmt = connection.prepareStatement("SELECT id, name, productionDate, damaged, weight FROM Gun WHERE damaged=false");
		updateGunStmt = connection.prepareStatement("UPDATE Gun SET name=?, productionDate=?, damaged=?, weight=? WHERE id=?");
	}
	
	@Override
	public int addGun(Gun gun) {
		int count = 0;
		try {
			addGunStmt.setString(1, gun.getName());
			addGunStmt.setString(2, gun.getProductionDate());
			addGunStmt.setBoolean(3, gun.isDamaged());
			addGunStmt.setDouble(4, gun.getWeight());
			count = addGunStmt.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return count;
	}
	
	@Override
	public void addAllGuns(List<Gun> guns) {
		try {
			connection.setAutoCommit(false);
			for(Gun gun : guns) {
				addGunStmt.setString(1, gun.getName());
				addGunStmt.setString(2, gun.getProductionDate());
				addGunStmt.setBoolean(3, gun.isDamaged());
				addGunStmt.setDouble(4, gun.getWeight());
				addGunStmt.executeUpdate();
			}
			connection.commit();
		} catch (SQLException e) {
			try {
				connection.rollback();
			} catch (SQLException e1) {
				e1.printStackTrace();
			}
			e.printStackTrace();
		} finally {
			try {
				connection.setAutoCommit(true);
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		
	}
	
	@Override
	public Gun getGun(long id) {
		Gun g = null;
		try {
			getGunStmt.setLong(1, id);
			ResultSet rs = getGunStmt.executeQuery();
			while (rs.next()) {
				g = new Gun();
				g.setId(rs.getInt("id"));
				g.setName(rs.getString("name"));
				g.setProductionDate(rs.getString("productionDate"));
				g.setDamaged(rs.getBoolean("damaged"));
				g.setWeight(rs.getDouble("weight"));
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return g;
	}
	
	@Override
	public List<Gun> getAllGuns(){
		List<Gun> guns = new ArrayList<Gun>();
		
		try {
			ResultSet rs = getAllGunsStmt.executeQuery();

			while (rs.next()) {
				Gun g = new Gun();
				g.setId(rs.getInt("id"));
				g.setName(rs.getString("name"));
				g.setProductionDate(rs.getString("productionDate"));
				g.setDamaged(rs.getBoolean("damaged"));
				g.setWeight(rs.getDouble("weight"));
				guns.add(g);
			}

		} catch (SQLException e) {
			e.printStackTrace();
		}
		
		return guns;
	}
	
	@Override
	public List<Gun> getAllGunsASC(){
		List<Gun> guns = getAllGuns();
		
		Collections.sort(guns, new Comparator<Gun>() {
		    @Override
		    public int compare(Gun g1, Gun g2) {
		        return g1.getName().compareToIgnoreCase(g2.getName());
		    }
		});
		
		return guns;
	}
	
	@Override
	public List<Gun> getAllGunsDESC(){
		List<Gun> guns = getAllGuns();
		
		Collections.sort(guns, new Comparator<Gun>() {
		    @Override
		    public int compare(Gun g1, Gun g2) {
		        return g2.getName().compareToIgnoreCase(g1.getName());
		    }
		});
		
		return guns;
	}
	
	@Override
	public List<Gun> getAllUndamagedGuns() {
		List<Gun> guns = new ArrayList<Gun>();
		
		try {
			ResultSet rs = getAllUndamagedGunsStmt.executeQuery();

			while (rs.next()) {
				Gun g = new Gun();
				g.setId(rs.getInt("id"));
				g.setName(rs.getString("name"));
				g.setProductionDate(rs.getString("productionDate"));
				g.setDamaged(rs.getBoolean("damaged"));
				g.setWeight(rs.getDouble("weight"));
				guns.add(g);
			}

		} catch (SQLException e) {
			e.printStackTrace();
		}
		
		return guns;
	}
	
	@Override
	public int deleteGun(Gun gun) {
		int count = 0;
		try {
			deleteGunStmt.setLong(1, gun.getId());
			count = deleteGunStmt.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return count;
	}

	@Override
	public void deleteAllGuns() {
		try {
			deleteAllGunsStmt.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	@Override
	public int updateGun(Gun gun) {
		int count = 0;
		try {
			updateGunStmt.setString(1, gun.getName());
			updateGunStmt.setString(2, gun.getProductionDate());
			updateGunStmt.setBoolean(3, gun.isDamaged());
			updateGunStmt.setDouble(4, gun.getWeight());
			updateGunStmt.setLong(5, gun.getId());
			count = updateGunStmt.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return count;
	}

}
